---
import { Image } from 'astro:assets';
import type { CollectionEntry } from 'astro:content';
import BaseHead from '../components/BaseHead.astro';
import Footer from '../components/Footer.astro';
import FormattedDate from '../components/FormattedDate.astro';
import Header from '../components/Header.astro';

type Props = CollectionEntry<'blog'>['data'] & {
	related?: CollectionEntry<'blog'>[];
};

const {
	title,
	description,
	pubDate,
	updatedDate,
	heroImage,
	context,
	readMinutes,
	aiModel,
	aiMode,
	aiState,
	aiLatencyMs,
	aiConfidence,
	wordCount,
	tokenCount,
	related = [],
} = Astro.props;

// 终端风格日期
const fmt = (d: Date) => d.toISOString().slice(0, 10);
const compact = (n: number) => (n >= 1000 ? `${(n / 1000).toFixed(1)}k` : String(n));
const contextText = context ?? description;
const hasSystemMeta = Boolean(aiModel || aiMode || aiState);
const hasResponseMeta = aiLatencyMs !== undefined || aiConfidence !== undefined;
const hasStats = aiModel || wordCount !== undefined || tokenCount !== undefined;
const confidenceText = aiConfidence !== undefined ? aiConfidence.toFixed(2) : undefined;

// 点云：全屏分散但不过于稀疏
const w = 1200; const h = 800;
const pts: { x: number; y: number; r: number; depth: number }[] = [];
const pad = 50;
for (let i = 0; i < 58; i++) {
	const x = pad + Math.random() * (w - pad * 2);
	const y = pad + Math.random() * (h - pad * 2);
	const depth = Math.random();
	pts.push({
		x, y,
		r: 1.1 + depth * 1.3,
		depth,
	});
}
const connectDist = 138;
const edges: [number, number][] = [];
for (let i = 0; i < pts.length; i++) {
	for (let j = i + 1; j < pts.length; j++) {
		const d = Math.hypot(pts[i].x - pts[j].x, pts[i].y - pts[j].y);
		if (d < connectDist) edges.push([i, j]);
	}
}
---

<html lang="en">
	<head>
		<BaseHead title={title} description={description} />
		<style>
			main {
				width: calc(100% - 2em);
				max-width: 100%;
				margin: 0;
			}
			.hero-shell {
				width: min(1020px, 100%);
				margin: 0 auto;
				position: relative;
				box-sizing: border-box;
			}
			.hero-image {
				width: 100%;
				margin: 0;
				position: relative;
				box-sizing: border-box;
				border-radius: 0;
				overflow: hidden;
			}
			.hero-pane {
				position: relative;
				border-radius: 12px;
				overflow: hidden;
				border: 1px solid rgba(156, 192, 218, 0.36);
				box-shadow:
					0 0 0 1px rgba(186, 222, 246, 0.14),
					0 24px 48px rgba(8, 18, 30, 0.68),
					0 0 34px rgba(8, 18, 30, 0.64);
			}
			.hero-stack {
				position: relative;
				aspect-ratio: 1020 / 510;
				background: #0a1218;
			}
			.hero-canvas-wrap {
				position: absolute;
				inset: 0;
				z-index: 1;
				opacity: 0;
				transition: opacity 260ms ease;
			}
			.hero-canvas-wrap.ready { opacity: 1; }
			.hero-canvas {
				position: absolute;
				inset: 0;
				width: 100%;
				height: 100%;
				display: block;
			}
			.hero-frame {
				position: absolute;
				top: 0.65rem;
				left: 0.8rem;
				display: inline-flex;
				align-items: center;
				gap: 0.52rem;
				padding: 0.26rem 0.62rem;
				border: 1px solid rgba(164, 206, 232, 0.44);
				background: rgba(8, 18, 30, 0.8);
				border-radius: 6px;
				font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
				font-size: 0.65rem;
				letter-spacing: 0.14em;
				color: rgba(208, 236, 254, 0.9);
				text-transform: uppercase;
				pointer-events: none;
				z-index: 2;
				box-shadow:
					0 0 0 1px rgba(176, 216, 240, 0.14),
					0 0 14px rgba(20, 54, 84, 0.4);
			}
			.hero-frame-dot {
				width: 6px;
				height: 6px;
				border-radius: 50%;
				background: rgba(255, 64, 82, 0.98);
				box-shadow: 0 0 10px rgba(255, 72, 96, 0.72);
				animation: hero-frame-alert 1.1s ease-in-out infinite;
			}
			.hero-threat-bar {
				width: 100%;
				margin: 0;
				display: flex;
				justify-content: space-between;
				gap: 0.6rem;
				padding: 0.24rem 0.5rem;
				box-sizing: border-box;
				border-top: 1px solid rgba(164, 206, 232, 0.24);
				background: linear-gradient(90deg, rgba(10, 22, 38, 0.7), rgba(8, 16, 28, 0.76));
				border-radius: 0;
				font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
				font-size: 0.58rem;
				letter-spacing: 0.12em;
				color: rgba(188, 226, 248, 0.82);
				text-transform: uppercase;
				pointer-events: none;
				z-index: 1;
			}
			@keyframes hero-frame-alert {
				0%,
				100% {
					opacity: 1;
					transform: scale(1);
				}
				50% {
					opacity: 0.35;
					transform: scale(0.82);
				}
			}
			@media (max-width: 720px) {
				.hero-frame {
					font-size: 0.6rem;
					letter-spacing: 0.1em;
				}
				.hero-threat-bar {
					font-size: 0.52rem;
					letter-spacing: 0.08em;
				}
			}
			.prose {
				width: 720px;
				max-width: calc(100% - 2em);
				margin: auto;
				padding: 1em;
				color: rgb(var(--text));
			}
			.hero-shell + .prose {
				margin-top: 1.1rem;
			}
			.rq-tv {
				position: fixed;
				left: clamp(0.6rem, 1.8vw, 1.4rem);
				top: 25vh;
				width: clamp(144px, 11vw, 196px);
				aspect-ratio: 4 / 3;
				z-index: 22;
				border-radius: 10px;
				padding: 7px;
				box-sizing: border-box;
				background:
					linear-gradient(165deg, rgba(34, 58, 78, 0.95), rgba(10, 19, 30, 0.94)),
					radial-gradient(circle at 18% 8%, rgba(164, 214, 244, 0.24), rgba(164, 214, 244, 0));
				border: 1px solid rgba(130, 178, 208, 0.34);
				box-shadow:
					0 14px 30px rgba(4, 10, 18, 0.58),
					0 0 0 1px rgba(170, 214, 240, 0.16),
					inset 0 1px 0 rgba(220, 242, 255, 0.22);
				overflow: hidden;
				backdrop-filter: blur(1.5px);
			}
			.rq-tv::before {
				content: "";
				position: absolute;
				inset: 0;
				pointer-events: none;
				background:
					repeating-linear-gradient(
						180deg,
						rgba(182, 232, 255, 0.14) 0 1px,
						rgba(182, 232, 255, 0) 1px 4px
					);
				mix-blend-mode: screen;
				opacity: 0.36;
			}
			.rq-tv-screen {
				position: relative;
				width: 100%;
				height: 100%;
				border-radius: 7px;
				display: block;
				background: transparent;
				border: 1px solid rgba(132, 186, 218, 0.34);
				box-shadow:
					inset 0 0 0 1px rgba(162, 214, 242, 0.12),
					inset 0 0 18px rgba(86, 150, 196, 0.2);
			}
			.rq-tv-badge {
				position: absolute;
				left: 0.55rem;
				bottom: 0.42rem;
				font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
				font-size: 0.5rem;
				letter-spacing: 0.12em;
				text-transform: uppercase;
				color: rgba(174, 220, 246, 0.78);
				text-shadow: 0 0 8px rgba(110, 188, 236, 0.36);
				pointer-events: none;
			}
			.rq-tv-dot {
				display: inline-block;
				width: 5px;
				height: 5px;
				border-radius: 50%;
				margin-left: 0.35rem;
				background: rgba(254, 84, 108, 0.98);
				box-shadow: 0 0 8px rgba(254, 90, 120, 0.7);
				animation: rq-tv-dot-blink 1.3s ease-in-out infinite;
				vertical-align: middle;
			}
			@keyframes rq-tv-dot-blink {
				0%, 100% { opacity: 1; }
				50% { opacity: 0.28; }
			}
			@media (max-width: 720px) {
				.hero-shell + .prose {
					margin-top: 0.85rem;
				}
			}
			@media (max-width: 1300px) {
				.rq-tv { display: none; }
			}
			.title {
				margin-bottom: 1em;
				padding: 1em 0;
				text-align: center;
				line-height: 1;
			}
			.title h1 {
				margin: 0 0 0.5em 0;
			}
			.mesh-title-flow {
				position: relative;
				height: 3px;
				margin: 0.75rem 0 0.1rem;
				border-radius: 999px;
				overflow: hidden;
				background: linear-gradient(
					90deg,
					rgba(96, 176, 255, 0.22),
					rgba(132, 214, 255, 0.3),
					rgba(96, 176, 255, 0.22)
				);
				box-shadow:
					0 0 0 1px rgba(148, 216, 244, 0.08),
					0 0 14px rgba(124, 206, 246, 0.24);
			}
			.mesh-title-flow::before {
				content: "";
				position: absolute;
				inset: 0;
				background: repeating-linear-gradient(
					90deg,
					rgba(162, 224, 250, 0.18) 0 9px,
					rgba(162, 224, 250, 0) 9px 16px
				);
			}
			.mesh-title-flow::after {
				content: "";
				position: absolute;
				top: 0;
				bottom: 0;
				left: -35%;
				width: 35%;
				background: linear-gradient(
					90deg,
					rgba(132, 214, 255, 0),
					rgba(164, 228, 255, 0.88),
					rgba(132, 214, 255, 0)
				);
				animation: mesh-title-flow-run 3.8s linear infinite;
			}
			@keyframes mesh-title-flow-run {
				to {
					left: 100%;
				}
			}
			.mesh-stage-toast {
				position: fixed;
				right: 1rem;
				bottom: 1rem;
				z-index: 56;
				padding: 0.5rem 0.75rem;
				font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
				font-size: 0.7rem;
				letter-spacing: 0.08em;
				text-transform: uppercase;
				color: rgba(214, 246, 255, 0.98);
				background: rgba(6, 16, 28, 0.94);
				border: 1px solid rgba(132, 214, 255, 0.44);
				border-radius: 6px;
				box-shadow:
					0 0 0 1px rgba(132, 214, 255, 0.16),
					0 0 24px rgba(124, 206, 246, 0.32);
				opacity: 0;
				transform: translateY(8px);
				pointer-events: none;
				transition:
					opacity 0.18s ease,
					transform 0.18s ease;
			}
			.mesh-stage-toast.visible {
				opacity: 1;
				transform: translateY(0);
			}
			.date {
				margin-bottom: 0.5em;
				color: rgb(var(--text-muted));
			}
			.last-updated-on {
				font-style: italic;
			}
		</style>
	</head>

	<body class="mesh-page">
		<div class="mesh-bg" aria-hidden="true">
			<div class="mesh-glow mesh-glow-shift"></div>
			<div class="mesh-haze" aria-hidden="true"></div>
			<div class="mesh-vignette" aria-hidden="true"></div>
			<div class="mesh-stripe"></div>
			<div class="mesh-noise" aria-hidden="true"></div>
			<div class="mesh-hex-grid" aria-hidden="true"></div>
			<div class="mesh-thought-particles" aria-hidden="true">
				{[...Array(12)].map((_, i) => (
					<span class="mesh-particle" style={`--x: ${20 + (i * 7) % 60}%; --y: ${10 + (i * 11) % 70}%; --d: ${3 + (i % 4)}s`}></span>
				))}
			</div>
			<svg class="mesh-network" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid slice">
					<defs>
						<linearGradient id="mesh-line-grad" x1="0%" y1="0%" x2="100%" y2="0%">
							<stop offset="0%" stop-color="rgba(180,235,255,0.26)" />
							<stop offset="50%" stop-color="rgba(236,252,255,0.74)" />
							<stop offset="100%" stop-color="rgba(180,235,255,0.26)" />
						</linearGradient>
						<filter id="mesh-dot-glow">
							<feGaussianBlur stdDeviation="2.2" result="blur" />
							<feMerge>
								<feMergeNode in="blur" />
								<feMergeNode in="SourceGraphic" />
						</feMerge>
					</filter>
				</defs>
				<g class="mesh-lines">
					{edges.map(([i, j]) => (
						<line
							x1={pts[i].x}
							y1={pts[i].y}
							x2={pts[j].x}
							y2={pts[j].y}
							stroke="url(#mesh-line-grad)"
							stroke-width="0.4"
						/>
					))}
				</g>
				<g class="mesh-dots">
					{pts.map((p) => (
						<circle
								cx={p.x}
								cy={p.y}
								r={p.r}
								fill={`rgba(232,255,255,${0.72 + p.depth * 0.48})`}
								filter="url(#mesh-dot-glow)"
							/>
						))}
				</g>
			</svg>
		</div>
		<Header />
		<aside class="rq-tv" aria-hidden="true">
			<canvas class="rq-tv-screen" width="320" height="240" data-rq-src="/images/redqueen-reference.jpg"></canvas>
			<div class="rq-tv-badge">monitor feed<span class="rq-tv-dot"></span></div>
		</aside>
		<div class="mesh-read-progress" aria-hidden="true"></div>
		<button type="button" class="mesh-back-to-top" aria-label="Back to top" title="Back to top">↑</button>
		<div class="mesh-stage-toast" aria-live="polite" aria-atomic="true"></div>
		<div class="mesh-mouse-glow" aria-hidden="true"></div>
		<div class="mesh-depth-blur" aria-hidden="true"></div>
		<div class="mesh-thinking-dots" aria-hidden="true"><span></span><span></span><span></span></div>
		<main class="mesh-content">
			<div class="mesh-load-scan" aria-hidden="true"></div>
				<article class="mesh-article">
					{heroImage && (
						<div class="hero-shell">
							<div class="hero-pane">
								<div class="hero-image">
									<div class="hero-stack">
										<div class="hero-canvas-wrap" aria-hidden="true">
											<canvas class="hero-canvas" data-hero-src={heroImage.src}></canvas>
										</div>
									</div>
									<div class="hero-frame" aria-hidden="true">
										<span>neural monitor</span>
										<span class="hero-frame-dot"></span>
									</div>
								</div>
								<div class="hero-threat-bar" aria-hidden="true">
									<span>signal sync active</span>
									<span>model online</span>
								</div>
							</div>
						</div>
					)}
				<div class="prose">
						<div class="title mesh-title">
							<div class="mesh-meta-terminal">
								$ published {fmt(pubDate)}
								{updatedDate && <> | updated {fmt(updatedDate)}</>}
								{readMinutes !== undefined && <> | ~{readMinutes} min read</>}
							</div>
							{hasSystemMeta && (
								<div class="mesh-system-row" aria-label="Model status">
									{aiModel && <span class="mesh-system-chip">model: {aiModel}</span>}
									{aiMode && <span class="mesh-system-chip">mode: {aiMode}</span>}
									{aiState && <span class="mesh-system-chip">state: {aiState}</span>}
								</div>
							)}
							{contextText && (
								<div class="mesh-prompt-line">
									Context: <span class="mesh-prompt-topic">{contextText}</span> →
								</div>
							)}
							<h1 class="mesh-title-text">{title}</h1>
							<hr />
							<div class="mesh-title-flow" aria-hidden="true"></div>
						</div>
						<div class="mesh-response-wrap">
							<div class="mesh-response-header">
								<div class="mesh-response-avatar" aria-hidden="true"></div>
								<span class="mesh-response-label">Output</span>
								{hasResponseMeta && (
									<div class="mesh-response-meta">
										{aiLatencyMs !== undefined && <span>latency est <strong>{aiLatencyMs}</strong> ms</span>}
										{confidenceText !== undefined && <span>confidence <strong>{confidenceText}</strong></span>}
									</div>
								)}
							</div>
							<div class="mesh-prose-body mesh-prose-fade">
								<slot />
								<span class="mesh-block-cursor" aria-hidden="true"></span>
							</div>
						</div>
						{hasStats && (
							<div class="mesh-stats-corner">
								{aiModel && <span class="mesh-model-id">{aiModel}</span>}
								{aiModel && (wordCount !== undefined || tokenCount !== undefined) && ' · '}
								{wordCount !== undefined && <span>{compact(wordCount)} words</span>}
								{wordCount !== undefined && tokenCount !== undefined && ' · '}
								{tokenCount !== undefined && <span>{compact(tokenCount)} tokens</span>}
							</div>
						)}
						<button type="button" class="mesh-regenerate" aria-label="Regenerate">Regenerate</button>
					</div>
				</article>
			{related.length > 0 && (
				<section class="mesh-related" aria-label="Related posts">
					<h2 class="mesh-related-title">Related</h2>
					<div class="mesh-related-grid">
						{related.map((p) => (
							<a href={`/blog/${p.id}/`} class="mesh-related-card">
								{p.data.heroImage ? (
									<div class="mesh-related-img">
										<Image width={320} height={180} src={p.data.heroImage} alt="" />
									</div>
								) : (
									<div class="mesh-related-placeholder">
										<span>{p.data.title.charAt(0)}</span>
									</div>
								)}
								<h3 class="mesh-related-card-title">{p.data.title}</h3>
								<p class="mesh-related-card-date">
									<FormattedDate date={p.data.pubDate} />
								</p>
							</a>
						))}
					</div>
				</section>
			)}
			<nav class="mesh-back-to-blog" aria-label="Back to blog">
				<a href="/blog/">
					<span class="mesh-back-prompt">$</span>
					<span class="mesh-back-text">← Back to blog</span>
				</a>
			</nav>
		</main>
		<Footer />
		<script is:inline>
			(function() {
				function init() {
				// 阅读进度条
				var progress = document.querySelector('.mesh-read-progress');
				var article = document.querySelector('.mesh-article');
				var toast = document.querySelector('.mesh-stage-toast');
				var stageSeen = { p30: false, p60: false, p90: false };
				var toastTimer = 0;
				var hasScrolled = false;
				function showStageToast(msg) {
					if (!toast) return;
					toast.textContent = msg;
					toast.classList.add('visible');
					clearTimeout(toastTimer);
					toastTimer = setTimeout(function() {
						toast.classList.remove('visible');
					}, 900);
				}
				if (progress) {
					function onScroll() {
						var scrollTop = window.scrollY || document.documentElement.scrollTop;
						var scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
						var p = scrollHeight > 0 ? Math.min(1, scrollTop / scrollHeight) : 1;
						progress.style.setProperty('--read-progress', String(p));
						var btn = document.querySelector('.mesh-back-to-top');
						if (btn) btn.classList.toggle('visible', scrollTop > 400);
						if (!hasScrolled && scrollTop > 6) hasScrolled = true;
						if (!hasScrolled) return;
						if (!stageSeen.p30 && p >= 0.3) {
							stageSeen.p30 = true;
							showStageToast('context parsed');
						}
						if (!stageSeen.p60 && p >= 0.6) {
							stageSeen.p60 = true;
							showStageToast('inference stable');
						}
						if (!stageSeen.p90 && p >= 0.9) {
							stageSeen.p90 = true;
							showStageToast('output finalized');
						}
					}
					onScroll();
					window.addEventListener('scroll', onScroll, { passive: true });
				}
				var backTop = document.querySelector('.mesh-back-to-top');
				if (backTop) {
					backTop.addEventListener('click', function() {
						window.scrollTo({ top: 0, behavior: 'smooth' });
					});
				}
				function initHeroCanvas() {
					var shell = document.querySelector('.hero-shell');
					if (!shell) return;
					var canvas = shell.querySelector('.hero-canvas');
					var wrap = shell.querySelector('.hero-canvas-wrap');
					if (!canvas || !wrap) return;
					var src = canvas.getAttribute('data-hero-src');
					if (!src) return;

					function draw() {
						var rect = shell.querySelector('.hero-stack').getBoundingClientRect();
						var dpr = Math.min(window.devicePixelRatio || 1, 2);
						canvas.width = Math.max(2, Math.round(rect.width * dpr));
						canvas.height = Math.max(2, Math.round(rect.height * dpr));
						canvas.style.width = rect.width + 'px';
						canvas.style.height = rect.height + 'px';
						var ctx = canvas.getContext('2d');
						if (!ctx || !canvas.img) return;
						var img = canvas.img;
						var w = canvas.width, h = canvas.height;
						var iw = img.width, ih = img.height;
						var scale = Math.max(w / iw, h / ih);
						var sw = w / scale, sh = h / scale;
						var sx = (iw - sw) / 2, sy = (ih - sh) / 2;
						ctx.drawImage(img, sx, sy, sw, sh, 0, 0, w, h);
					}

					var img = new Image();
					img.onload = function() {
						canvas.img = img;
						wrap.classList.add('ready');
						draw();
					};
					img.src = new URL(src, window.location.href).href;

					window.addEventListener('resize', function() { if (canvas.img) draw(); }, { passive: true });
				}
				initHeroCanvas();
				function initRedQueenTv() {
					var tv = document.querySelector('.rq-tv-screen');
					if (!tv) return;
					var ctx = tv.getContext('2d');
					if (!ctx) return;
					var width = tv.width;
					var height = tv.height;
					var source = tv.getAttribute('data-rq-src') || '';
					var raf = 0;
					var start = performance.now();
					var speakingUntil = 0;
					var nextSpeakAt = 2.6 + Math.random() * 3.4;
					var blinkingUntil = 0;
					var nextBlinkAt = 1.2 + Math.random() * 2.4;
					var wobbleUntil = 0;
					var nextWobbleAt = 2.2 + Math.random() * 4.2;
					var lookUntil = 0;
					var nextLookAt = 1.6 + Math.random() * 3.8;
					var lookOffset = 0;
					var cutout = null;
					var cutW = 0;
					var cutH = 0;

					function clamp(v, min, max) {
						return Math.max(min, Math.min(max, v));
					}

					function buildCutout(img) {
						var t = document.createElement('canvas');
						t.width = img.width;
						t.height = img.height;
						var tctx = t.getContext('2d');
						if (!tctx) return null;
						tctx.drawImage(img, 0, 0);
						var imageData = tctx.getImageData(0, 0, t.width, t.height);
						var d = imageData.data;
						var minX = t.width, minY = t.height, maxX = 0, maxY = 0;
						for (var i = 0; i < d.length; i += 4) {
							var r = d[i];
							var g = d[i + 1];
							var b = d[i + 2];
							var a = d[i + 3];
							if (a === 0) continue;
							var luma = 0.299 * r + 0.587 * g + 0.114 * b;
							var redBias = r - (g * 0.58 + b * 0.42);
							var alpha = clamp((redBias + 34) * 3.2 + (luma - 38) * 1.4, 0, 255);
							if (r < 36 && g < 36 && b < 40) alpha = 0;
							if (alpha < 12) alpha = 0;
							d[i] = clamp(r * 0.78 + 24, 0, 255);
							d[i + 1] = clamp(g * 0.92 + 30, 0, 255);
							d[i + 2] = clamp(b * 1.18 + 40, 0, 255);
							d[i + 3] = Math.min(a, alpha);
							if (d[i + 3] > 18) {
								var px = (i / 4) % t.width;
								var py = Math.floor((i / 4) / t.width);
								if (px < minX) minX = px;
								if (px > maxX) maxX = px;
								if (py < minY) minY = py;
								if (py > maxY) maxY = py;
							}
						}
						tctx.putImageData(imageData, 0, 0);
						if (maxX <= minX || maxY <= minY) return null;
						var padX = Math.round((maxX - minX) * 0.08);
						var padY = Math.round((maxY - minY) * 0.08);
						minX = clamp(minX - padX, 0, t.width - 1);
						maxX = clamp(maxX + padX, 0, t.width - 1);
						minY = clamp(minY - padY, 0, t.height - 1);
						maxY = clamp(maxY + padY, 0, t.height - 1);
						cutW = maxX - minX + 1;
						cutH = maxY - minY + 1;
						var c = document.createElement('canvas');
						c.width = cutW;
						c.height = cutH;
						var cctx = c.getContext('2d');
						if (!cctx) return null;
						cctx.drawImage(t, minX, minY, cutW, cutH, 0, 0, cutW, cutH);
						return c;
					}

					function drawFallback(elapsed) {
						ctx.clearRect(0, 0, width, height);
						ctx.fillStyle = 'rgba(124, 186, 224, 0.15)';
						ctx.beginPath();
						ctx.ellipse(width * 0.5, height * 0.52, 36, 44, 0, 0, Math.PI * 2);
						ctx.fill();
						ctx.strokeStyle = 'rgba(176, 226, 250, 0.66)';
						ctx.stroke();
						ctx.fillStyle = 'rgba(182, 232, 255, 0.08)';
						for (var i = 0; i < 6; i++) {
							var y = (elapsed * 34 + i * 42) % height;
							ctx.fillRect(0, y, width, 1);
						}
					}

					function drawPanel(t) {
						var elapsed = (t - start) * 0.001;
						var talking = elapsed < speakingUntil;
						var wobbling = elapsed < wobbleUntil;
						var blinking = elapsed < blinkingUntil;
						var looking = elapsed < lookUntil;
						if (elapsed > nextSpeakAt) {
							speakingUntil = elapsed + 0.45 + Math.random() * 0.75;
							nextSpeakAt = speakingUntil + 2.8 + Math.random() * 4.2;
						}
						if (elapsed > nextBlinkAt) {
							blinkingUntil = elapsed + 0.14;
							nextBlinkAt = blinkingUntil + 2.1 + Math.random() * 2.7;
						}
						if (elapsed > nextWobbleAt) {
							wobbleUntil = elapsed + 0.45 + Math.random() * 0.65;
							nextWobbleAt = wobbleUntil + 3.8 + Math.random() * 5.2;
						}
						if (elapsed > nextLookAt) {
							lookUntil = elapsed + 0.85;
							nextLookAt = lookUntil + 2.8 + Math.random() * 3.6;
							lookOffset = (Math.random() - 0.5) * 1.6;
						}
						if (!cutout) {
							drawFallback(elapsed);
							raf = requestAnimationFrame(drawPanel);
							return;
						}

						var centerX = width * 0.5;
						var centerY = height * 0.55;
						var bob = Math.sin(elapsed * 1.2) * 0.8;
						var sway = wobbling ? Math.sin(elapsed * 9.2) * 2.1 : Math.sin(elapsed * 0.85) * 0.55;
						var tilt = wobbling ? Math.sin(elapsed * 8.2) * 0.018 : Math.sin(elapsed * 0.7) * 0.007;
						var mouthPower = talking ? (0.4 + Math.abs(Math.sin(elapsed * 18)) * 0.6) : 0;
						var blinkT = blinking ? Math.abs(Math.sin(elapsed * 38)) : 0;
						var eyeShift = looking ? lookOffset : 0;

						ctx.clearRect(0, 0, width, height);

						ctx.save();
						ctx.translate(centerX + sway, centerY + bob);
						ctx.rotate(tilt);

						var targetW = width * 0.78;
						var targetH = height * 0.88;
						var ratio = Math.min(targetW / cutW, targetH / cutH);
						var dw = cutW * ratio;
						var dh = cutH * ratio;
						var dx = -dw * 0.44;
						var dy = -dh * 0.56;

						var halo = ctx.createRadialGradient(dx + dw * 0.54, dy + dh * 0.36, 10, dx + dw * 0.54, dy + dh * 0.36, dw * 0.7);
						halo.addColorStop(0, 'rgba(160, 232, 255, 0.26)');
						halo.addColorStop(1, 'rgba(160, 232, 255, 0)');
						ctx.fillStyle = halo;
						ctx.fillRect(dx - 20, dy - 20, dw + 40, dh + 40);

						ctx.globalAlpha = 0.92;
						ctx.drawImage(cutout, dx, dy, dw, dh);
						if (mouthPower > 0.02) {
							var mSX = cutW * 0.43;
							var mSY = cutH * 0.55;
							var mSW = cutW * 0.2;
							var mSH = cutH * 0.13;
							var mDX = dx + dw * 0.43;
							var mDY = dy + dh * 0.55;
							var mouthOpen = 1 + mouthPower * 0.28;
							ctx.globalAlpha = 0.6;
							ctx.drawImage(
								cutout,
								mSX,
								mSY,
								mSW,
								mSH,
								mDX,
								mDY + mouthPower * 1.8,
								dw * 0.2,
								dh * 0.13 * mouthOpen
							);
						}
						ctx.globalAlpha = 1;

						ctx.globalCompositeOperation = 'screen';
						ctx.fillStyle = 'rgba(154, 230, 255, 0.14)';
						ctx.fillRect(dx, dy, dw, dh);
						ctx.globalCompositeOperation = 'source-over';

						var eY = dy + dh * 0.34;
						var eW = dw * 0.045;
						var eH = dh * (0.02 - blinkT * 0.015);
						ctx.fillStyle = 'rgba(210, 244, 255, 0.6)';
						ctx.fillRect(dx + dw * 0.46 + eyeShift, eY, eW, Math.max(1, eH));
						ctx.fillRect(dx + dw * 0.57 + eyeShift, eY + 0.4, eW, Math.max(1, eH));

						ctx.strokeStyle = 'rgba(176, 234, 255, 0.56)';
						ctx.lineWidth = 0.95;
						ctx.beginPath();
						ctx.moveTo(0, -84);
						ctx.lineTo(0, 76);
						ctx.moveTo(-95, -20);
						ctx.lineTo(95, -20);
						ctx.stroke();

						ctx.restore();

						ctx.globalCompositeOperation = 'screen';
						for (var i = 0; i < 7; i++) {
							var y = (elapsed * 28 + i * 36) % height;
							ctx.fillStyle = i % 2 ? 'rgba(188,238,255,0.05)' : 'rgba(188,238,255,0.08)';
							ctx.fillRect(0, y, width, 1);
						}
						ctx.globalCompositeOperation = 'source-over';

						var sweepX = (Math.sin(elapsed * 0.9) * 0.5 + 0.5) * width;
						var sweep = ctx.createLinearGradient(sweepX - 80, 0, sweepX + 80, 0);
						sweep.addColorStop(0, 'rgba(176, 230, 255, 0)');
						sweep.addColorStop(0.5, 'rgba(176, 230, 255, 0.12)');
						sweep.addColorStop(1, 'rgba(176, 230, 255, 0)');
						ctx.fillStyle = sweep;
						ctx.fillRect(0, 0, width, height);

						raf = requestAnimationFrame(drawPanel);
					}

					if (source) {
						var img = new Image();
						img.onload = function() { cutout = buildCutout(img); };
						img.onerror = function() { cutout = null; };
						img.src = new URL(source, window.location.href).href;
					}

					drawPanel(performance.now());
					window.addEventListener('beforeunload', function() { cancelAnimationFrame(raf); }, { once: true });
				}
				initRedQueenTv();

				// 鼠标跟随光斑
				var glow = document.querySelector('.mesh-mouse-glow');
				if (glow) {
					var raf;
					var x = 0, y = 0;
					document.addEventListener('mousemove', function(e) {
						x = e.clientX;
						y = e.clientY;
						if (!raf) raf = requestAnimationFrame(function() {
							glow.style.setProperty('--mouse-x', x + 'px');
							glow.style.setProperty('--mouse-y', y + 'px');
							raf = 0;
						});
					});
				}

				// 悬浮预览卡：为链接添加 data-preview
				document.querySelectorAll('.mesh-prose-body a[href]').forEach(function(a) {
					var href = a.getAttribute('href') || '';
					if (!href || href.startsWith('#')) return;
					a.classList.add('mesh-link-preview');
					try {
						a.setAttribute('data-preview', href.startsWith('http') ? new URL(href, location.origin).hostname : href);
					} catch (_) {
						a.setAttribute('data-preview', href);
					}
				});

				// 段落滚动浮现
				var paras = document.querySelectorAll('.mesh-prose-body p, .mesh-prose-body h2, .mesh-prose-body h3, .mesh-prose-body pre, .mesh-prose-body blockquote, .mesh-prose-body ul, .mesh-prose-body ol');
				if (window.IntersectionObserver) {
					var io = new IntersectionObserver(function(entries) {
						entries.forEach(function(e) {
							if (e.isIntersecting) {
								e.target.classList.add('mesh-para-visible');
								io.unobserve(e.target);
							}
						});
					}, { rootMargin: '0px 0px -60px 0px', threshold: 0.1 });
					paras.forEach(function(p) { io.observe(p); });
				} else {
					paras.forEach(function(p) { p.classList.add('mesh-para-visible'); });
				}

				// Regenerate 按钮
				var regen = document.querySelector('.mesh-regenerate');
				var article = document.querySelector('.mesh-article');
				var scan = document.querySelector('.mesh-load-scan');
				if (regen && article) {
					regen.addEventListener('click', function() {
						regen.disabled = true;
						regen.classList.add('mesh-regenerating');
						article.classList.add('mesh-regenerate-flash');
						if (scan) {
							scan.style.animation = 'none';
							scan.offsetHeight;
							scan.style.animation = 'mesh-scan 0.8s ease-out forwards';
							scan.style.top = '0';
							scan.style.opacity = '1';
						}
						setTimeout(function() {
							article.classList.remove('mesh-regenerate-flash');
							regen.classList.remove('mesh-regenerating');
							regen.disabled = false;
						}, 1200);
					});
				}
			}

			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', init);
			} else {
				init();
			}
		})();
		</script>
	</body>
</html>
