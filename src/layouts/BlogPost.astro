---
import { Image } from 'astro:assets';
import type { CollectionEntry } from 'astro:content';
import BaseHead from '../components/BaseHead.astro';
import Footer from '../components/Footer.astro';
import FormattedDate from '../components/FormattedDate.astro';
import Header from '../components/Header.astro';

type Props = CollectionEntry<'blog'>['data'] & {
	related?: CollectionEntry<'blog'>[];
};

const {
	title,
	description,
	pubDate,
	updatedDate,
	heroImage,
	context,
	readMinutes,
	aiModel,
	aiMode,
	aiState,
	aiLatencyMs,
	aiConfidence,
	wordCount,
	tokenCount,
	related = [],
} = Astro.props;

// 终端风格日期
const fmt = (d: Date) => d.toISOString().slice(0, 10);
const compact = (n: number) => (n >= 1000 ? `${(n / 1000).toFixed(1)}k` : String(n));
const contextText = context ?? description;
const hasSystemMeta = Boolean(aiModel || aiMode || aiState);
const hasResponseMeta = aiLatencyMs !== undefined || aiConfidence !== undefined;
const hasStats = aiModel || wordCount !== undefined || tokenCount !== undefined;
const confidenceText = aiConfidence !== undefined ? aiConfidence.toFixed(2) : undefined;

// 点云：全屏分散但不过于稀疏
const w = 1200; const h = 800;
const pts: { x: number; y: number; r: number; depth: number }[] = [];
const pad = 50;
for (let i = 0; i < 58; i++) {
	const x = pad + Math.random() * (w - pad * 2);
	const y = pad + Math.random() * (h - pad * 2);
	const depth = Math.random();
	pts.push({
		x, y,
		r: 1.1 + depth * 1.3,
		depth,
	});
}
const connectDist = 138;
const edges: [number, number][] = [];
for (let i = 0; i < pts.length; i++) {
	for (let j = i + 1; j < pts.length; j++) {
		const d = Math.hypot(pts[i].x - pts[j].x, pts[i].y - pts[j].y);
		if (d < connectDist) edges.push([i, j]);
	}
}
---

<html lang="en">
	<head>
		<BaseHead title={title} description={description} />
		<style>
			main {
				width: calc(100% - 2em);
				max-width: 100%;
				margin: 0;
			}
			.hero-shell {
				width: min(1020px, 100%);
				margin: 0 auto;
				position: relative;
				box-sizing: border-box;
			}
			.hero-image {
				width: 100%;
				margin: 0;
				position: relative;
				box-sizing: border-box;
				border-radius: 0;
				overflow: hidden;
			}
			.hero-pane {
				position: relative;
				border-radius: 12px;
				overflow: hidden;
				border: 1px solid rgba(156, 192, 218, 0.36);
				box-shadow:
					0 0 0 1px rgba(186, 222, 246, 0.14),
					0 24px 48px rgba(8, 18, 30, 0.68),
					0 0 34px rgba(8, 18, 30, 0.64);
			}
			.hero-stack {
				position: relative;
				aspect-ratio: 1020 / 510;
				background: #0a1218;
			}
			.hero-canvas-wrap {
				position: absolute;
				inset: 0;
				z-index: 1;
				opacity: 0;
				transition: opacity 260ms ease;
			}
			.hero-canvas-wrap.ready { opacity: 1; }
			.hero-canvas {
				position: absolute;
				inset: 0;
				width: 100%;
				height: 100%;
				display: block;
			}
			.hero-frame {
				position: absolute;
				top: 0.65rem;
				left: 0.8rem;
				display: inline-flex;
				align-items: center;
				gap: 0.52rem;
				padding: 0.26rem 0.62rem;
				border: 1px solid rgba(164, 206, 232, 0.44);
				background: rgba(8, 18, 30, 0.8);
				border-radius: 6px;
				font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
				font-size: 0.65rem;
				letter-spacing: 0.14em;
				color: rgba(208, 236, 254, 0.9);
				text-transform: uppercase;
				pointer-events: none;
				z-index: 2;
				box-shadow:
					0 0 0 1px rgba(176, 216, 240, 0.14),
					0 0 14px rgba(20, 54, 84, 0.4);
			}
			.hero-frame-dot {
				width: 6px;
				height: 6px;
				border-radius: 50%;
				background: rgba(255, 64, 82, 0.98);
				box-shadow: 0 0 10px rgba(255, 72, 96, 0.72);
				animation: hero-frame-alert 1.1s ease-in-out infinite;
			}
			.hero-threat-bar {
				width: 100%;
				margin: 0;
				display: flex;
				justify-content: space-between;
				gap: 0.6rem;
				padding: 0.24rem 0.5rem;
				box-sizing: border-box;
				border-top: 1px solid rgba(164, 206, 232, 0.24);
				background: linear-gradient(90deg, rgba(10, 22, 38, 0.7), rgba(8, 16, 28, 0.76));
				border-radius: 0;
				font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
				font-size: 0.58rem;
				letter-spacing: 0.12em;
				color: rgba(188, 226, 248, 0.82);
				text-transform: uppercase;
				pointer-events: none;
				z-index: 1;
			}
			@keyframes hero-frame-alert {
				0%,
				100% {
					opacity: 1;
					transform: scale(1);
				}
				50% {
					opacity: 0.35;
					transform: scale(0.82);
				}
			}
			@media (max-width: 720px) {
				.hero-frame {
					font-size: 0.6rem;
					letter-spacing: 0.1em;
				}
				.hero-threat-bar {
					font-size: 0.52rem;
					letter-spacing: 0.08em;
				}
			}
			.prose {
				width: 720px;
				max-width: calc(100% - 2em);
				margin: auto;
				padding: 1em;
				color: rgb(var(--text));
			}
			.hero-shell + .prose {
				margin-top: 1.1rem;
			}
			@media (max-width: 720px) {
				.hero-shell + .prose {
					margin-top: 0.85rem;
				}
			}
			.title {
				margin-bottom: 1em;
				padding: 1em 0;
				text-align: center;
				line-height: 1;
			}
			.title h1 {
				margin: 0 0 0.5em 0;
			}
			.mesh-title-flow {
				position: relative;
				height: 3px;
				margin: 0.75rem 0 0.1rem;
				border-radius: 999px;
				overflow: hidden;
				background: linear-gradient(
					90deg,
					rgba(96, 176, 255, 0.22),
					rgba(132, 214, 255, 0.3),
					rgba(96, 176, 255, 0.22)
				);
				box-shadow:
					0 0 0 1px rgba(148, 216, 244, 0.08),
					0 0 14px rgba(124, 206, 246, 0.24);
			}
			.mesh-title-flow::before {
				content: "";
				position: absolute;
				inset: 0;
				background: repeating-linear-gradient(
					90deg,
					rgba(162, 224, 250, 0.18) 0 9px,
					rgba(162, 224, 250, 0) 9px 16px
				);
			}
			.mesh-title-flow::after {
				content: "";
				position: absolute;
				top: 0;
				bottom: 0;
				left: -35%;
				width: 35%;
				background: linear-gradient(
					90deg,
					rgba(132, 214, 255, 0),
					rgba(164, 228, 255, 0.88),
					rgba(132, 214, 255, 0)
				);
				animation: mesh-title-flow-run 3.8s linear infinite;
			}
			@keyframes mesh-title-flow-run {
				to {
					left: 100%;
				}
			}
			.mesh-stage-toast {
				position: fixed;
				right: 1rem;
				bottom: 1rem;
				z-index: 56;
				padding: 0.5rem 0.75rem;
				font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
				font-size: 0.7rem;
				letter-spacing: 0.08em;
				text-transform: uppercase;
				color: rgba(214, 246, 255, 0.98);
				background: rgba(6, 16, 28, 0.94);
				border: 1px solid rgba(132, 214, 255, 0.44);
				border-radius: 6px;
				box-shadow:
					0 0 0 1px rgba(132, 214, 255, 0.16),
					0 0 24px rgba(124, 206, 246, 0.32);
				opacity: 0;
				transform: translateY(8px);
				pointer-events: none;
				transition:
					opacity 0.18s ease,
					transform 0.18s ease;
			}
			.mesh-stage-toast.visible {
				opacity: 1;
				transform: translateY(0);
			}
			.date {
				margin-bottom: 0.5em;
				color: rgb(var(--text-muted));
			}
			.last-updated-on {
				font-style: italic;
			}
		</style>
	</head>

	<body class="mesh-page">
		<div class="mesh-bg" aria-hidden="true">
			<div class="mesh-glow mesh-glow-shift"></div>
			<div class="mesh-haze" aria-hidden="true"></div>
			<div class="mesh-vignette" aria-hidden="true"></div>
			<div class="mesh-stripe"></div>
			<div class="mesh-noise" aria-hidden="true"></div>
			<div class="mesh-hex-grid" aria-hidden="true"></div>
			<div class="mesh-thought-particles" aria-hidden="true">
				{[...Array(12)].map((_, i) => (
					<span class="mesh-particle" style={`--x: ${20 + (i * 7) % 60}%; --y: ${10 + (i * 11) % 70}%; --d: ${3 + (i % 4)}s`}></span>
				))}
			</div>
			<svg class="mesh-network" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid slice">
					<defs>
						<linearGradient id="mesh-line-grad" x1="0%" y1="0%" x2="100%" y2="0%">
							<stop offset="0%" stop-color="rgba(180,235,255,0.26)" />
							<stop offset="50%" stop-color="rgba(236,252,255,0.74)" />
							<stop offset="100%" stop-color="rgba(180,235,255,0.26)" />
						</linearGradient>
						<filter id="mesh-dot-glow">
							<feGaussianBlur stdDeviation="2.2" result="blur" />
							<feMerge>
								<feMergeNode in="blur" />
								<feMergeNode in="SourceGraphic" />
						</feMerge>
					</filter>
				</defs>
				<g class="mesh-lines">
					{edges.map(([i, j]) => (
						<line
							x1={pts[i].x}
							y1={pts[i].y}
							x2={pts[j].x}
							y2={pts[j].y}
							stroke="url(#mesh-line-grad)"
							stroke-width="0.4"
						/>
					))}
				</g>
				<g class="mesh-dots">
					{pts.map((p) => (
						<circle
								cx={p.x}
								cy={p.y}
								r={p.r}
								fill={`rgba(232,255,255,${0.72 + p.depth * 0.48})`}
								filter="url(#mesh-dot-glow)"
							/>
						))}
				</g>
			</svg>
		</div>
		<Header />
		<div class="mesh-read-progress" aria-hidden="true"></div>
		<button type="button" class="mesh-back-to-top" aria-label="Back to top" title="Back to top">↑</button>
		<div class="mesh-stage-toast" aria-live="polite" aria-atomic="true"></div>
		<div class="mesh-mouse-glow" aria-hidden="true"></div>
		<div class="mesh-depth-blur" aria-hidden="true"></div>
		<div class="mesh-thinking-dots" aria-hidden="true"><span></span><span></span><span></span></div>
		<main class="mesh-content">
			<div class="mesh-load-scan" aria-hidden="true"></div>
				<article class="mesh-article">
					{heroImage && (
						<div class="hero-shell">
							<div class="hero-pane">
								<div class="hero-image">
									<div class="hero-stack">
										<div class="hero-canvas-wrap" aria-hidden="true">
											<canvas class="hero-canvas" data-hero-src={heroImage.src}></canvas>
										</div>
									</div>
									<div class="hero-frame" aria-hidden="true">
										<span>neural monitor</span>
										<span class="hero-frame-dot"></span>
									</div>
								</div>
								<div class="hero-threat-bar" aria-hidden="true">
									<span>signal sync active</span>
									<span>model online</span>
								</div>
							</div>
						</div>
					)}
				<div class="prose">
						<div class="title mesh-title">
							<div class="mesh-meta-terminal">
								$ published {fmt(pubDate)}
								{updatedDate && <> | updated {fmt(updatedDate)}</>}
								{readMinutes !== undefined && <> | ~{readMinutes} min read</>}
							</div>
							{hasSystemMeta && (
								<div class="mesh-system-row" aria-label="Model status">
									{aiModel && <span class="mesh-system-chip">model: {aiModel}</span>}
									{aiMode && <span class="mesh-system-chip">mode: {aiMode}</span>}
									{aiState && <span class="mesh-system-chip">state: {aiState}</span>}
								</div>
							)}
							{contextText && (
								<div class="mesh-prompt-line">
									Context: <span class="mesh-prompt-topic">{contextText}</span> →
								</div>
							)}
							<h1 class="mesh-title-text">{title}</h1>
							<hr />
							<div class="mesh-title-flow" aria-hidden="true"></div>
						</div>
						<div class="mesh-response-wrap">
							<div class="mesh-response-header">
								<div class="mesh-response-avatar" aria-hidden="true"></div>
								<span class="mesh-response-label">Output</span>
								{hasResponseMeta && (
									<div class="mesh-response-meta">
										{aiLatencyMs !== undefined && <span>latency est <strong>{aiLatencyMs}</strong> ms</span>}
										{confidenceText !== undefined && <span>confidence <strong>{confidenceText}</strong></span>}
									</div>
								)}
							</div>
							<div class="mesh-prose-body mesh-prose-fade">
								<slot />
								<span class="mesh-block-cursor" aria-hidden="true"></span>
							</div>
						</div>
						{hasStats && (
							<div class="mesh-stats-corner">
								{aiModel && <span class="mesh-model-id">{aiModel}</span>}
								{aiModel && (wordCount !== undefined || tokenCount !== undefined) && ' · '}
								{wordCount !== undefined && <span>{compact(wordCount)} words</span>}
								{wordCount !== undefined && tokenCount !== undefined && ' · '}
								{tokenCount !== undefined && <span>{compact(tokenCount)} tokens</span>}
							</div>
						)}
						<button type="button" class="mesh-regenerate" aria-label="Regenerate">Regenerate</button>
					</div>
				</article>
			{related.length > 0 && (
				<section class="mesh-related" aria-label="Related posts">
					<h2 class="mesh-related-title">Related</h2>
					<div class="mesh-related-grid">
						{related.map((p) => (
							<a href={`/blog/${p.id}/`} class="mesh-related-card">
								{p.data.heroImage ? (
									<div class="mesh-related-img">
										<Image width={320} height={180} src={p.data.heroImage} alt="" />
									</div>
								) : (
									<div class="mesh-related-placeholder">
										<span>{p.data.title.charAt(0)}</span>
									</div>
								)}
								<h3 class="mesh-related-card-title">{p.data.title}</h3>
								<p class="mesh-related-card-date">
									<FormattedDate date={p.data.pubDate} />
								</p>
							</a>
						))}
					</div>
				</section>
			)}
			<nav class="mesh-back-to-blog" aria-label="Back to blog">
				<a href="/blog/">
					<span class="mesh-back-prompt">$</span>
					<span class="mesh-back-text">← Back to blog</span>
				</a>
			</nav>
		</main>
		<Footer />
		<script is:inline>
			(function() {
				function init() {
				// 阅读进度条
				var progress = document.querySelector('.mesh-read-progress');
				var article = document.querySelector('.mesh-article');
				var toast = document.querySelector('.mesh-stage-toast');
				var stageSeen = { p30: false, p60: false, p90: false };
				var toastTimer = 0;
				var hasScrolled = false;
				function showStageToast(msg) {
					if (!toast) return;
					toast.textContent = msg;
					toast.classList.add('visible');
					clearTimeout(toastTimer);
					toastTimer = setTimeout(function() {
						toast.classList.remove('visible');
					}, 900);
				}
				if (progress) {
					function onScroll() {
						var scrollTop = window.scrollY || document.documentElement.scrollTop;
						var scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
						var p = scrollHeight > 0 ? Math.min(1, scrollTop / scrollHeight) : 1;
						progress.style.setProperty('--read-progress', String(p));
						var btn = document.querySelector('.mesh-back-to-top');
						if (btn) btn.classList.toggle('visible', scrollTop > 400);
						if (!hasScrolled && scrollTop > 6) hasScrolled = true;
						if (!hasScrolled) return;
						if (!stageSeen.p30 && p >= 0.3) {
							stageSeen.p30 = true;
							showStageToast('context parsed');
						}
						if (!stageSeen.p60 && p >= 0.6) {
							stageSeen.p60 = true;
							showStageToast('inference stable');
						}
						if (!stageSeen.p90 && p >= 0.9) {
							stageSeen.p90 = true;
							showStageToast('output finalized');
						}
					}
					onScroll();
					window.addEventListener('scroll', onScroll, { passive: true });
				}
				var backTop = document.querySelector('.mesh-back-to-top');
				if (backTop) {
					backTop.addEventListener('click', function() {
						window.scrollTo({ top: 0, behavior: 'smooth' });
					});
				}
				function initHeroCanvas() {
					var shell = document.querySelector('.hero-shell');
					if (!shell) return;
					var canvas = shell.querySelector('.hero-canvas');
					var wrap = shell.querySelector('.hero-canvas-wrap');
					if (!canvas || !wrap) return;
					var src = canvas.getAttribute('data-hero-src');
					if (!src) return;

					function draw() {
						var rect = shell.querySelector('.hero-stack').getBoundingClientRect();
						var dpr = Math.min(window.devicePixelRatio || 1, 2);
						canvas.width = Math.max(2, Math.round(rect.width * dpr));
						canvas.height = Math.max(2, Math.round(rect.height * dpr));
						canvas.style.width = rect.width + 'px';
						canvas.style.height = rect.height + 'px';
						var ctx = canvas.getContext('2d');
						if (!ctx || !canvas.img) return;
						var img = canvas.img;
						var w = canvas.width, h = canvas.height;
						var iw = img.width, ih = img.height;
						var scale = Math.max(w / iw, h / ih);
						var sw = w / scale, sh = h / scale;
						var sx = (iw - sw) / 2, sy = (ih - sh) / 2;
						ctx.drawImage(img, sx, sy, sw, sh, 0, 0, w, h);
					}

					var img = new Image();
					img.onload = function() {
						canvas.img = img;
						wrap.classList.add('ready');
						draw();
					};
					img.src = new URL(src, window.location.href).href;

					window.addEventListener('resize', function() { if (canvas.img) draw(); }, { passive: true });
				}
				initHeroCanvas();

				// 鼠标跟随光斑
				var glow = document.querySelector('.mesh-mouse-glow');
				if (glow) {
					var raf;
					var x = 0, y = 0;
					document.addEventListener('mousemove', function(e) {
						x = e.clientX;
						y = e.clientY;
						if (!raf) raf = requestAnimationFrame(function() {
							glow.style.setProperty('--mouse-x', x + 'px');
							glow.style.setProperty('--mouse-y', y + 'px');
							raf = 0;
						});
					});
				}

				// 悬浮预览卡：为链接添加 data-preview
				document.querySelectorAll('.mesh-prose-body a[href]').forEach(function(a) {
					var href = a.getAttribute('href') || '';
					if (!href || href.startsWith('#')) return;
					a.classList.add('mesh-link-preview');
					try {
						a.setAttribute('data-preview', href.startsWith('http') ? new URL(href, location.origin).hostname : href);
					} catch (_) {
						a.setAttribute('data-preview', href);
					}
				});

				// 段落滚动浮现
				var paras = document.querySelectorAll('.mesh-prose-body p, .mesh-prose-body h2, .mesh-prose-body h3, .mesh-prose-body pre, .mesh-prose-body blockquote, .mesh-prose-body ul, .mesh-prose-body ol');
				if (window.IntersectionObserver) {
					var io = new IntersectionObserver(function(entries) {
						entries.forEach(function(e) {
							if (e.isIntersecting) {
								e.target.classList.add('mesh-para-visible');
								io.unobserve(e.target);
							}
						});
					}, { rootMargin: '0px 0px -60px 0px', threshold: 0.1 });
					paras.forEach(function(p) { io.observe(p); });
				} else {
					paras.forEach(function(p) { p.classList.add('mesh-para-visible'); });
				}

				// Regenerate 按钮
				var regen = document.querySelector('.mesh-regenerate');
				var article = document.querySelector('.mesh-article');
				var scan = document.querySelector('.mesh-load-scan');
				if (regen && article) {
					regen.addEventListener('click', function() {
						regen.disabled = true;
						regen.classList.add('mesh-regenerating');
						article.classList.add('mesh-regenerate-flash');
						if (scan) {
							scan.style.animation = 'none';
							scan.offsetHeight;
							scan.style.animation = 'mesh-scan 0.8s ease-out forwards';
							scan.style.top = '0';
							scan.style.opacity = '1';
						}
						setTimeout(function() {
							article.classList.remove('mesh-regenerate-flash');
							regen.classList.remove('mesh-regenerating');
							regen.disabled = false;
						}, 1200);
					});
				}
			}

			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', init);
			} else {
				init();
			}
		})();
		</script>
	</body>
</html>
