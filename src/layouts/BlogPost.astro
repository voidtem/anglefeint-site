---
import { Image } from 'astro:assets';
import type { CollectionEntry } from 'astro:content';
import BaseHead from '../components/BaseHead.astro';
import Footer from '../components/Footer.astro';
import FormattedDate from '../components/FormattedDate.astro';
import Header from '../components/Header.astro';
import { SITE_AUTHOR } from '../consts';

type Props = CollectionEntry<'blog'>['data'] & {
	related?: CollectionEntry<'blog'>[];
};

const {
	title,
	description,
	pubDate,
	updatedDate,
	heroImage,
	context,
	readMinutes,
	aiModel,
	aiMode,
	aiState,
	aiLatencyMs,
	aiConfidence,
	wordCount,
	tokenCount,
	author,
	tags,
	related = [],
} = Astro.props;

// 终端风格日期
const fmt = (d: Date) => d.toISOString().slice(0, 10);
const compact = (n: number) => (n >= 1000 ? `${(n / 1000).toFixed(1)}k` : String(n));
const contextText = context ?? description;
const hasSystemMeta = Boolean(aiModel || aiMode || aiState);
const hasResponseMeta = aiLatencyMs !== undefined || aiConfidence !== undefined;
const hasStats = aiModel || wordCount !== undefined || tokenCount !== undefined;
const confidenceText = aiConfidence !== undefined ? aiConfidence.toFixed(2) : undefined;

// 点云：全屏分散但不过于稀疏
const w = 1200; const h = 800;
const pts: { x: number; y: number; r: number; depth: number }[] = [];
const pad = 50;
for (let i = 0; i < 58; i++) {
	const x = pad + Math.random() * (w - pad * 2);
	const y = pad + Math.random() * (h - pad * 2);
	const depth = Math.random();
	pts.push({
		x, y,
		r: 1.1 + depth * 1.3,
		depth,
	});
}
const connectDist = 138;
const edges: [number, number][] = [];
for (let i = 0; i < pts.length; i++) {
	for (let j = i + 1; j < pts.length; j++) {
		const d = Math.hypot(pts[i].x - pts[j].x, pts[i].y - pts[j].y);
		if (d < connectDist) edges.push([i, j]);
	}
}
---

<html lang="en">
	<head>
		<BaseHead
			title={title}
			description={description}
			image={heroImage}
			pageType="article"
			publishedTime={pubDate}
			modifiedTime={updatedDate}
			author={author ?? SITE_AUTHOR}
			tags={tags}
		/>
		<style>
			main {
				width: calc(100% - 2em);
				max-width: 100%;
				margin: 0;
			}
			.hero-shell {
				width: min(1020px, 100%);
				margin: 0 auto;
				position: relative;
				box-sizing: border-box;
			}
			.hero-image {
				width: 100%;
				margin: 0;
				position: relative;
				box-sizing: border-box;
				border-radius: 0;
				overflow: hidden;
			}
			.hero-pane {
				position: relative;
				border-radius: 12px;
				overflow: hidden;
				border: 1px solid rgba(156, 192, 218, 0.36);
				box-shadow:
					0 0 0 1px rgba(186, 222, 246, 0.14),
					0 24px 48px rgba(8, 18, 30, 0.68),
					0 0 34px rgba(8, 18, 30, 0.64);
			}
			.hero-stack {
				position: relative;
				aspect-ratio: 1020 / 510;
				background: #0a1218;
			}
			.hero-canvas-wrap {
				position: absolute;
				inset: 0;
				z-index: 1;
				opacity: 0;
				transition: opacity 260ms ease;
			}
			.hero-canvas-wrap.ready { opacity: 1; }
			.hero-canvas {
				position: absolute;
				inset: 0;
				width: 100%;
				height: 100%;
				display: block;
			}
			.hero-frame {
				position: absolute;
				top: 0.65rem;
				left: 0.8rem;
				display: inline-flex;
				align-items: center;
				gap: 0.52rem;
				padding: 0.26rem 0.62rem;
				border: 1px solid rgba(164, 206, 232, 0.44);
				background: rgba(8, 18, 30, 0.8);
				border-radius: 6px;
				font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
				font-size: 0.65rem;
				letter-spacing: 0.14em;
				color: rgba(208, 236, 254, 0.9);
				text-transform: uppercase;
				pointer-events: none;
				z-index: 2;
				box-shadow:
					0 0 0 1px rgba(176, 216, 240, 0.14),
					0 0 14px rgba(20, 54, 84, 0.4);
			}
			.hero-frame-dot {
				width: 6px;
				height: 6px;
				border-radius: 50%;
				background: rgba(255, 64, 82, 0.98);
				box-shadow: 0 0 10px rgba(255, 72, 96, 0.72);
				animation: hero-frame-alert 1.1s ease-in-out infinite;
			}
			.hero-threat-bar {
				width: 100%;
				margin: 0;
				display: flex;
				justify-content: space-between;
				gap: 0.6rem;
				padding: 0.24rem 0.5rem;
				box-sizing: border-box;
				border-top: 1px solid rgba(164, 206, 232, 0.24);
				background: linear-gradient(90deg, rgba(10, 22, 38, 0.7), rgba(8, 16, 28, 0.76));
				border-radius: 0;
				font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
				font-size: 0.58rem;
				letter-spacing: 0.12em;
				color: rgba(188, 226, 248, 0.82);
				text-transform: uppercase;
				pointer-events: none;
				z-index: 1;
			}
			@keyframes hero-frame-alert {
				0%,
				100% {
					opacity: 1;
					transform: scale(1);
				}
				50% {
					opacity: 0.35;
					transform: scale(0.82);
				}
			}
			@media (max-width: 720px) {
				.hero-frame {
					font-size: 0.6rem;
					letter-spacing: 0.1em;
				}
				.hero-threat-bar {
					font-size: 0.52rem;
					letter-spacing: 0.08em;
				}
			}
			.prose {
				width: 720px;
				max-width: calc(100% - 2em);
				margin: auto;
				padding: 1em;
				color: rgb(var(--text));
			}
			.hero-shell + .prose {
				margin-top: 1.1rem;
			}
			.rq-tv {
				position: fixed;
				left: clamp(0.6rem, 1.8vw, 1.4rem);
				top: 25vh;
				width: clamp(144px, 11vw, 196px);
				aspect-ratio: 4 / 3;
				z-index: 22;
				border-radius: 10px;
				padding: 7px;
				box-sizing: border-box;
				background:
					linear-gradient(165deg, rgba(34, 58, 78, 0.95), rgba(10, 19, 30, 0.94)),
					radial-gradient(circle at 18% 8%, rgba(164, 214, 244, 0.24), rgba(164, 214, 244, 0));
				border: 1px solid rgba(130, 178, 208, 0.34);
				box-shadow:
					0 14px 30px rgba(4, 10, 18, 0.58),
					0 0 0 1px rgba(170, 214, 240, 0.16),
					inset 0 1px 0 rgba(220, 242, 255, 0.22);
				overflow: hidden;
				backdrop-filter: blur(1.5px);
			}
			.rq-tv::before {
				content: "";
				position: absolute;
				inset: 0;
				pointer-events: none;
				background:
					repeating-linear-gradient(
						180deg,
						rgba(182, 232, 255, 0.14) 0 1px,
						rgba(182, 232, 255, 0) 1px 4px
					);
				mix-blend-mode: screen;
				opacity: 0.36;
			}
			.rq-tv-screen {
				position: relative;
				width: 100%;
				height: 100%;
				border-radius: 7px;
				display: block;
				background: transparent;
				border: 1px solid rgba(132, 186, 218, 0.34);
				box-shadow:
					inset 0 0 0 1px rgba(162, 214, 242, 0.12),
					inset 0 0 18px rgba(86, 150, 196, 0.2);
			}
			.rq-tv-badge {
				position: absolute;
				left: 0.55rem;
				bottom: 0.42rem;
				font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
				font-size: 0.5rem;
				letter-spacing: 0.12em;
				text-transform: uppercase;
				color: rgba(174, 220, 246, 0.78);
				text-shadow: 0 0 8px rgba(110, 188, 236, 0.36);
				pointer-events: none;
			}
			.rq-tv-dot {
				display: inline-block;
				width: 5px;
				height: 5px;
				border-radius: 50%;
				margin-left: 0.35rem;
				background: rgba(254, 84, 108, 0.98);
				box-shadow: 0 0 8px rgba(254, 90, 120, 0.7);
				animation: rq-tv-dot-blink 1.3s ease-in-out infinite;
				vertical-align: middle;
			}
			@keyframes rq-tv-dot-blink {
				0%, 100% { opacity: 1; }
				50% { opacity: 0.28; }
			}
			@media (max-width: 720px) {
				.hero-shell + .prose {
					margin-top: 0.85rem;
				}
			}
			@media (max-width: 1300px) {
				.rq-tv { display: none; }
			}
			.title {
				margin-bottom: 1em;
				padding: 1em 0;
				text-align: center;
				line-height: 1;
			}
			.title h1 {
				margin: 0 0 0.5em 0;
			}
			.mesh-title-flow {
				position: relative;
				height: 3px;
				margin: 0.75rem 0 0.1rem;
				border-radius: 999px;
				overflow: hidden;
				background: linear-gradient(
					90deg,
					rgba(96, 176, 255, 0.22),
					rgba(132, 214, 255, 0.3),
					rgba(96, 176, 255, 0.22)
				);
				box-shadow:
					0 0 0 1px rgba(148, 216, 244, 0.08),
					0 0 14px rgba(124, 206, 246, 0.24);
			}
			.mesh-title-flow::before {
				content: "";
				position: absolute;
				inset: 0;
				background: repeating-linear-gradient(
					90deg,
					rgba(162, 224, 250, 0.18) 0 9px,
					rgba(162, 224, 250, 0) 9px 16px
				);
			}
			.mesh-title-flow::after {
				content: "";
				position: absolute;
				top: 0;
				bottom: 0;
				left: -35%;
				width: 35%;
				background: linear-gradient(
					90deg,
					rgba(132, 214, 255, 0),
					rgba(164, 228, 255, 0.88),
					rgba(132, 214, 255, 0)
				);
				animation: mesh-title-flow-run 3.8s linear infinite;
			}
			@keyframes mesh-title-flow-run {
				to {
					left: 100%;
				}
			}
			.mesh-stage-toast {
				position: fixed;
				right: 1rem;
				bottom: 1rem;
				z-index: 56;
				padding: 0.5rem 0.75rem;
				font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
				font-size: 0.7rem;
				letter-spacing: 0.08em;
				text-transform: uppercase;
				color: rgba(214, 246, 255, 0.98);
				background: rgba(6, 16, 28, 0.94);
				border: 1px solid rgba(132, 214, 255, 0.44);
				border-radius: 6px;
				box-shadow:
					0 0 0 1px rgba(132, 214, 255, 0.16),
					0 0 24px rgba(124, 206, 246, 0.32);
				opacity: 0;
				transform: translateY(8px);
				pointer-events: none;
				transition:
					opacity 0.18s ease,
					transform 0.18s ease;
			}
			.mesh-stage-toast.visible {
				opacity: 1;
				transform: translateY(0);
			}
			.date {
				margin-bottom: 0.5em;
				color: rgb(var(--text-muted));
			}
			.last-updated-on {
				font-style: italic;
			}
		</style>
	</head>

	<body class="mesh-page">
		<div class="mesh-bg" aria-hidden="true">
			<div class="mesh-glow mesh-glow-shift"></div>
			<div class="mesh-haze" aria-hidden="true"></div>
			<div class="mesh-vignette" aria-hidden="true"></div>
			<div class="mesh-stripe"></div>
			<div class="mesh-noise" aria-hidden="true"></div>
			<div class="mesh-hex-grid" aria-hidden="true"></div>
			<div class="mesh-thought-particles" aria-hidden="true">
				{[...Array(12)].map((_, i) => (
					<span class="mesh-particle" style={`--x: ${20 + (i * 7) % 60}%; --y: ${10 + (i * 11) % 70}%; --d: ${3 + (i % 4)}s`}></span>
				))}
			</div>
			<svg class="mesh-network" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid slice">
					<defs>
						<linearGradient id="mesh-line-grad" x1="0%" y1="0%" x2="100%" y2="0%">
							<stop offset="0%" stop-color="rgba(180,235,255,0.26)" />
							<stop offset="50%" stop-color="rgba(236,252,255,0.74)" />
							<stop offset="100%" stop-color="rgba(180,235,255,0.26)" />
						</linearGradient>
						<filter id="mesh-dot-glow">
							<feGaussianBlur stdDeviation="2.2" result="blur" />
							<feMerge>
								<feMergeNode in="blur" />
								<feMergeNode in="SourceGraphic" />
						</feMerge>
					</filter>
				</defs>
				<g class="mesh-lines">
					{edges.map(([i, j]) => (
						<line
							x1={pts[i].x}
							y1={pts[i].y}
							x2={pts[j].x}
							y2={pts[j].y}
							stroke="url(#mesh-line-grad)"
							stroke-width="0.4"
						/>
					))}
				</g>
				<g class="mesh-dots">
					{pts.map((p) => (
						<circle
								cx={p.x}
								cy={p.y}
								r={p.r}
								fill={`rgba(232,255,255,${0.72 + p.depth * 0.48})`}
								filter="url(#mesh-dot-glow)"
							/>
						))}
				</g>
			</svg>
		</div>
		<Header />
		<aside class="rq-tv" aria-hidden="true">
			<canvas class="rq-tv-screen" width="320" height="240" data-rq-src="/images/redqueen2.webp" data-rq-src2="/images/redqueen1.gif"></canvas>
			<div class="rq-tv-badge">monitor feed<span class="rq-tv-dot"></span></div>
		</aside>
		<div class="mesh-read-progress" aria-hidden="true"></div>
		<button type="button" class="mesh-back-to-top" aria-label="Back to top" title="Back to top">↑</button>
		<div class="mesh-stage-toast" aria-live="polite" aria-atomic="true"></div>
		<div class="mesh-mouse-glow" aria-hidden="true"></div>
		<div class="mesh-depth-blur" aria-hidden="true"></div>
		<div class="mesh-thinking-dots" aria-hidden="true"><span></span><span></span><span></span></div>
		<main class="mesh-content">
			<div class="mesh-load-scan" aria-hidden="true"></div>
				<article class="mesh-article">
					{heroImage && (
						<div class="hero-shell">
							<div class="hero-pane">
								<div class="hero-image">
									<div class="hero-stack">
										<div class="hero-canvas-wrap" aria-hidden="true">
											<canvas class="hero-canvas" data-hero-src={heroImage.src}></canvas>
										</div>
									</div>
									<div class="hero-frame" aria-hidden="true">
										<span>neural monitor</span>
										<span class="hero-frame-dot"></span>
									</div>
								</div>
								<div class="hero-threat-bar" aria-hidden="true">
									<span>signal sync active</span>
									<span>model online</span>
								</div>
							</div>
						</div>
					)}
				<div class="prose">
						<div class="title mesh-title">
							<div class="mesh-meta-terminal">
								$ published {fmt(pubDate)}
								{updatedDate && <> | updated {fmt(updatedDate)}</>}
								{readMinutes !== undefined && <> | ~{readMinutes} min read</>}
							</div>
							{hasSystemMeta && (
								<div class="mesh-system-row" aria-label="Model status">
									{aiModel && <span class="mesh-system-chip">model: {aiModel}</span>}
									{aiMode && <span class="mesh-system-chip">mode: {aiMode}</span>}
									{aiState && <span class="mesh-system-chip">state: {aiState}</span>}
								</div>
							)}
							{contextText && (
								<div class="mesh-prompt-line">
									Context: <span class="mesh-prompt-topic">{contextText}</span> →
								</div>
							)}
							<h1 class="mesh-title-text">{title}</h1>
							<hr />
							<div class="mesh-title-flow" aria-hidden="true"></div>
						</div>
						<div class="mesh-response-wrap">
							<div class="mesh-response-header">
								<div class="mesh-response-avatar" aria-hidden="true"></div>
								<span class="mesh-response-label">Output</span>
								{hasResponseMeta && (
									<div class="mesh-response-meta">
										{aiLatencyMs !== undefined && <span>latency est <strong>{aiLatencyMs}</strong> ms</span>}
										{confidenceText !== undefined && <span>confidence <strong>{confidenceText}</strong></span>}
									</div>
								)}
							</div>
							<div class="mesh-prose-body mesh-prose-fade">
								<slot />
								<span class="mesh-block-cursor" aria-hidden="true"></span>
							</div>
						</div>
						{hasStats && (
							<div class="mesh-stats-corner">
								{aiModel && <span class="mesh-model-id">{aiModel}</span>}
								{aiModel && (wordCount !== undefined || tokenCount !== undefined) && ' · '}
								{wordCount !== undefined && <span>{compact(wordCount)} words</span>}
								{wordCount !== undefined && tokenCount !== undefined && ' · '}
								{tokenCount !== undefined && <span>{compact(tokenCount)} tokens</span>}
							</div>
						)}
						<button type="button" class="mesh-regenerate" aria-label="Regenerate">Regenerate</button>
					</div>
				</article>
			{related.length > 0 && (
				<section class="mesh-related" aria-label="Related posts">
					<h2 class="mesh-related-title">Related</h2>
					<div class="mesh-related-grid">
						{related.map((p) => (
							<a href={`/blog/${p.id}/`} class="mesh-related-card">
								{p.data.heroImage ? (
									<div class="mesh-related-img">
										<Image width={320} height={180} src={p.data.heroImage} alt="" />
									</div>
								) : (
									<div class="mesh-related-placeholder">
										<span>{p.data.title.charAt(0)}</span>
									</div>
								)}
								<h3 class="mesh-related-card-title">{p.data.title}</h3>
								<p class="mesh-related-card-date">
									<FormattedDate date={p.data.pubDate} />
								</p>
							</a>
						))}
					</div>
				</section>
			)}
			<nav class="mesh-back-to-blog" aria-label="Back to blog">
				<a href="/blog/">
					<span class="mesh-back-prompt">$</span>
					<span class="mesh-back-text">← Back to blog</span>
				</a>
			</nav>
		</main>
		<Footer />
		<script is:inline>
			(function() {
				function init() {
				// 阅读进度条
				var progress = document.querySelector('.mesh-read-progress');
				var article = document.querySelector('.mesh-article');
				var toast = document.querySelector('.mesh-stage-toast');
				var stageSeen = { p30: false, p60: false, p90: false };
				var toastTimer = 0;
				var hasScrolled = false;
				function showStageToast(msg) {
					if (!toast) return;
					toast.textContent = msg;
					toast.classList.add('visible');
					clearTimeout(toastTimer);
					toastTimer = setTimeout(function() {
						toast.classList.remove('visible');
					}, 900);
				}
				if (progress) {
					function onScroll() {
						var scrollTop = window.scrollY || document.documentElement.scrollTop;
						var scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
						var p = scrollHeight > 0 ? Math.min(1, scrollTop / scrollHeight) : 1;
						progress.style.setProperty('--read-progress', String(p));
						var btn = document.querySelector('.mesh-back-to-top');
						if (btn) btn.classList.toggle('visible', scrollTop > 400);
						if (!hasScrolled && scrollTop > 6) hasScrolled = true;
						if (!hasScrolled) return;
						if (!stageSeen.p30 && p >= 0.3) {
							stageSeen.p30 = true;
							showStageToast('context parsed');
						}
						if (!stageSeen.p60 && p >= 0.6) {
							stageSeen.p60 = true;
							showStageToast('inference stable');
						}
						if (!stageSeen.p90 && p >= 0.9) {
							stageSeen.p90 = true;
							showStageToast('output finalized');
						}
					}
					onScroll();
					window.addEventListener('scroll', onScroll, { passive: true });
				}
				var backTop = document.querySelector('.mesh-back-to-top');
				if (backTop) {
					backTop.addEventListener('click', function() {
						window.scrollTo({ top: 0, behavior: 'smooth' });
					});
				}
				function initHeroCanvas() {
					var shell = document.querySelector('.hero-shell');
					if (!shell) return;
					var canvas = shell.querySelector('.hero-canvas');
					var wrap = shell.querySelector('.hero-canvas-wrap');
					if (!canvas || !wrap) return;
					var src = canvas.getAttribute('data-hero-src');
					if (!src) return;

					var heroStart = 0;
					var heroRaf = 0;
					// offscreen canvas for base image
					var baseCanvas = document.createElement('canvas');
					var baseCtx = baseCanvas.getContext('2d');
					// offscreen canvas for edge detection
					var edgeCanvas = document.createElement('canvas');
					var edgeCtx = edgeCanvas.getContext('2d');
					var edgeReady = false;

					// Phase timing (seconds)
					var EDGE_PHASE = 1.8;      // show edge detection
					var REVEAL_PHASE = 2.5;     // progressive reveal (pixelated -> sharp)
					var INTRO_END = EDGE_PHASE + REVEAL_PHASE; // after this, ongoing glitch

					function sizeCanvas() {
						var rect = shell.querySelector('.hero-stack').getBoundingClientRect();
						var dpr = Math.min(window.devicePixelRatio || 1, 2);
						canvas.width = Math.max(2, Math.round(rect.width * dpr));
						canvas.height = Math.max(2, Math.round(rect.height * dpr));
						canvas.style.width = rect.width + 'px';
						canvas.style.height = rect.height + 'px';
					}

					function drawBase(ctx, img, w, h) {
						var iw = img.width, ih = img.height;
						var scale = Math.max(w / iw, h / ih);
						var sw = w / scale, sh = h / scale;
						var sx = (iw - sw) / 2, sy = (ih - sh) / 2;
						ctx.drawImage(img, sx, sy, sw, sh, 0, 0, w, h);
					}

					function buildEdge(img) {
						var w = canvas.width, h = canvas.height;
						edgeCanvas.width = w;
						edgeCanvas.height = h;
						baseCanvas.width = w;
						baseCanvas.height = h;
						drawBase(baseCtx, img, w, h);
						drawBase(edgeCtx, img, w, h);
						// Sobel edge detection
						var src = edgeCtx.getImageData(0, 0, w, h);
						var d = src.data;
						var out = edgeCtx.createImageData(w, h);
						var od = out.data;
						for (var y = 1; y < h - 1; y++) {
							for (var x = 1; x < w - 1; x++) {
								var idx = function(px, py) { return ((py * w) + px) * 4; };
								var i = idx(x, y);
								// grayscale neighbors
								function luma(px, py) {
									var j = idx(px, py);
									return d[j] * 0.299 + d[j+1] * 0.587 + d[j+2] * 0.114;
								}
								var gx = -luma(x-1,y-1) - 2*luma(x-1,y) - luma(x-1,y+1)
								         + luma(x+1,y-1) + 2*luma(x+1,y) + luma(x+1,y+1);
								var gy = -luma(x-1,y-1) - 2*luma(x,y-1) - luma(x+1,y-1)
								         + luma(x-1,y+1) + 2*luma(x,y+1) + luma(x+1,y+1);
								var mag = Math.min(255, Math.sqrt(gx * gx + gy * gy));
								// cyan-tinted edges
								od[i]   = Math.min(255, mag * 0.4);
								od[i+1] = Math.min(255, mag * 0.85);
								od[i+2] = Math.min(255, mag * 1.0);
								od[i+3] = mag > 20 ? Math.min(255, mag * 1.5) : 0;
							}
						}
						edgeCtx.putImageData(out, 0, 0);
						edgeReady = true;
					}

					function heroRender(t) {
						if (!heroStart) heroStart = t;
						var elapsed = (t - heroStart) * 0.001;
						var ctx = canvas.getContext('2d');
						if (!ctx || !canvas.img) { heroRaf = requestAnimationFrame(heroRender); return; }
						var w = canvas.width, h = canvas.height;

						ctx.clearRect(0, 0, w, h);

						if (elapsed < EDGE_PHASE && edgeReady) {
							// Phase 1: Edge detection wireframe
							var edgeFade = Math.min(1, elapsed / 0.5);
							// dark background
							ctx.fillStyle = 'rgba(8, 16, 28, 1)';
							ctx.fillRect(0, 0, w, h);
							// draw edges with fade-in
							ctx.globalAlpha = edgeFade;
							ctx.drawImage(edgeCanvas, 0, 0);
							ctx.globalAlpha = 1;
							// scanning line
							var scanY = (elapsed / EDGE_PHASE) * h;
							ctx.fillStyle = 'rgba(120, 220, 255, 0.3)';
							ctx.fillRect(0, scanY - 1, w, 2);
							var scanGlow = ctx.createLinearGradient(0, scanY - 30, 0, scanY + 30);
							scanGlow.addColorStop(0, 'rgba(120, 220, 255, 0)');
							scanGlow.addColorStop(0.5, 'rgba(120, 220, 255, 0.15)');
							scanGlow.addColorStop(1, 'rgba(120, 220, 255, 0)');
							ctx.fillStyle = scanGlow;
							ctx.fillRect(0, scanY - 30, w, 60);

						} else if (elapsed < INTRO_END) {
							// Phase 2: Progressive reveal — pixelated to sharp
							var revealT = (elapsed - EDGE_PHASE) / REVEAL_PHASE;
							// pixel size: starts large, shrinks to 1
							var maxBlock = 32;
							var blockSize = Math.max(1, Math.round(maxBlock * (1 - revealT * revealT)));
							// draw pixelated
							if (blockSize > 1) {
								var tmpCanvas = document.createElement('canvas');
								var smallW = Math.max(1, Math.ceil(w / blockSize));
								var smallH = Math.max(1, Math.ceil(h / blockSize));
								tmpCanvas.width = smallW;
								tmpCanvas.height = smallH;
								var tmpCtx = tmpCanvas.getContext('2d');
								tmpCtx.drawImage(baseCanvas, 0, 0, smallW, smallH);
								ctx.imageSmoothingEnabled = false;
								ctx.drawImage(tmpCanvas, 0, 0, smallW, smallH, 0, 0, w, h);
								ctx.imageSmoothingEnabled = true;
							} else {
								ctx.drawImage(baseCanvas, 0, 0);
							}
							// fade out cyan tint
							var tintAlpha = 0.18 * (1 - revealT);
							ctx.globalCompositeOperation = 'screen';
							ctx.fillStyle = 'rgba(100, 200, 255, ' + tintAlpha + ')';
							ctx.fillRect(0, 0, w, h);
							ctx.globalCompositeOperation = 'source-over';

						} else {
							// Phase 3: Full image with ongoing scan + glitch
							ctx.drawImage(baseCanvas, 0, 0);

							// Scanlines
							ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
							for (var i = 0; i < h; i += 3) {
								ctx.fillRect(0, i, w, 1);
							}

							// Moving scan bar
							var scanPos = ((elapsed * 40) % (h + 60)) - 30;
							var barGrad = ctx.createLinearGradient(0, scanPos - 30, 0, scanPos + 30);
							barGrad.addColorStop(0, 'rgba(120, 220, 255, 0)');
							barGrad.addColorStop(0.5, 'rgba(120, 220, 255, 0.06)');
							barGrad.addColorStop(1, 'rgba(120, 220, 255, 0)');
							ctx.fillStyle = barGrad;
							ctx.fillRect(0, scanPos - 30, w, 60);

							// RGB channel glitch (random, ~8% of frames)
							if (Math.random() < 0.08) {
								var glitchY = Math.random() * h;
								var glitchH = 2 + Math.random() * 12;
								var shiftX = (Math.random() - 0.5) * 12;
								var strip = ctx.getImageData(0, Math.floor(glitchY), w, Math.ceil(glitchH));
								// shift red channel
								var sd = strip.data;
								var shiftPx = Math.round(shiftX) * 4;
								if (shiftPx > 0) {
									for (var j = sd.length - 4; j >= shiftPx; j -= 4) {
										sd[j] = sd[j - shiftPx];
									}
								} else if (shiftPx < 0) {
									for (var j = 0; j < sd.length + shiftPx; j += 4) {
										sd[j] = sd[j - shiftPx];
									}
								}
								ctx.putImageData(strip, 0, Math.floor(glitchY));
							}

							// Brief static burst (~3% of frames)
							if (Math.random() < 0.03) {
								var burstY = Math.random() * h * 0.8;
								var burstH = 4 + Math.random() * 20;
								var noise = ctx.createImageData(w, Math.ceil(burstH));
								var nd = noise.data;
								for (var j = 0; j < nd.length; j += 4) {
									var v = Math.random() * 255;
									nd[j] = v * 0.5;
									nd[j+1] = v * 0.8;
									nd[j+2] = v;
									nd[j+3] = 30 + Math.random() * 40;
								}
								ctx.putImageData(noise, 0, Math.floor(burstY));
							}
						}

						heroRaf = requestAnimationFrame(heroRender);
					}

					var img = new Image();
					img.onload = function() {
						canvas.img = img;
						sizeCanvas();
						buildEdge(img);
						wrap.classList.add('ready');
						heroRaf = requestAnimationFrame(heroRender);
					};
					img.src = new URL(src, window.location.href).href;

					window.addEventListener('resize', function() {
						if (canvas.img) {
							sizeCanvas();
							buildEdge(canvas.img);
						}
					}, { passive: true });
					window.addEventListener('beforeunload', function() { cancelAnimationFrame(heroRaf); }, { once: true });
				}
				initHeroCanvas();
			function initRedQueenTv() {
					var tv = document.querySelector('.rq-tv-screen');
					if (!tv) return;
					var ctx = tv.getContext('2d');
					if (!ctx) return;
					var width = tv.width;
					var height = tv.height;
					var source = tv.getAttribute('data-rq-src') || '';
					var source2 = tv.getAttribute('data-rq-src2') || '';
					if (!source) return;
					var raf = 0;
					var start = performance.now();
					var currentFrame = null;

					function drawFallback(elapsed) {
						ctx.clearRect(0, 0, width, height);
						ctx.fillStyle = 'rgba(124, 186, 224, 0.15)';
						ctx.beginPath();
						ctx.ellipse(width * 0.5, height * 0.52, 36, 44, 0, 0, Math.PI * 2);
						ctx.fill();
						ctx.strokeStyle = 'rgba(176, 226, 250, 0.66)';
						ctx.stroke();
						ctx.fillStyle = 'rgba(182, 232, 255, 0.08)';
						for (var i = 0; i < 6; i++) {
							var y = (elapsed * 34 + i * 42) % height;
							ctx.fillRect(0, y, width, 1);
						}
					}

					function drawOverlay(elapsed) {
						// scanlines
						ctx.globalCompositeOperation = 'screen';
						for (var i = 0; i < 7; i++) {
							var y = (elapsed * 28 + i * 36) % height;
							ctx.fillStyle = i % 2 ? 'rgba(188,238,255,0.05)' : 'rgba(188,238,255,0.08)';
							ctx.fillRect(0, y, width, 1);
						}
						ctx.globalCompositeOperation = 'source-over';
						// cyan tint overlay
						ctx.globalCompositeOperation = 'screen';
						ctx.fillStyle = 'rgba(154, 230, 255, 0.10)';
						ctx.fillRect(0, 0, width, height);
						ctx.globalCompositeOperation = 'source-over';
						// sweep light
						var sweepX = (Math.sin(elapsed * 0.9) * 0.5 + 0.5) * width;
						var sweep = ctx.createLinearGradient(sweepX - 80, 0, sweepX + 80, 0);
						sweep.addColorStop(0, 'rgba(176, 230, 255, 0)');
						sweep.addColorStop(0.5, 'rgba(176, 230, 255, 0.12)');
						sweep.addColorStop(1, 'rgba(176, 230, 255, 0)');
						ctx.fillStyle = sweep;
						ctx.fillRect(0, 0, width, height);
					}

					function drawFrame(frame) {
						var fw = frame.displayWidth || frame.width;
						var fh = frame.displayHeight || frame.height;
						var scale = Math.max(width / fw, height / fh) * 1.4;
						var dw = fw * scale;
						var dh = fh * scale;
						var dx = (width - dw) / 2 - 160;
						var dy = (height - dh) / 2;
						if (playlist[playlistIndex] && playlist[playlistIndex].type === 'image/gif') dy += 20;
						ctx.save();
						ctx.translate(width, 0);
						ctx.scale(-1, 1);
						ctx.drawImage(frame, dx, dy, dw, dh);
						ctx.restore();
					}

					function renderLoop(t) {
						var elapsed = (t - start) * 0.001;
						ctx.clearRect(0, 0, width, height);
						if (currentFrame) {
							drawFrame(currentFrame);
						} else {
							drawFallback(elapsed);
						}
						drawOverlay(elapsed);
						raf = requestAnimationFrame(renderLoop);
					}

						// Playlist: webp -> gif (hold 500ms) -> gif (hold 500ms) -> webp -> loop from 1
						var playlist = [
							{ url: '/images/redqueen2.webp', type: 'image/webp' },
							{ url: '/images/redqueen1.gif', type: 'image/gif', holdLast: 500 },
							{ url: '/images/redqueen1.gif', type: 'image/gif', holdLast: 500 },
							{ url: '/images/redqueen2.webp', type: 'image/webp' }
						];
					var loopFrom = 1;
					var playlistIndex = 0;

					function playItem(index) {
						playlistIndex = index;
						var item = playlist[index];
						if (!item || typeof ImageDecoder === 'undefined') return;
						fetch(new URL(item.url, window.location.href).href)
							.then(function(response) { return response.body; })
							.then(function(body) {
								var decoder = new ImageDecoder({ data: body, type: item.type });
								var frameIndex = 0;
								function decodeNext() {
									decoder.decode({ frameIndex: frameIndex }).then(function(result) {
										if (currentFrame && currentFrame.close) currentFrame.close();
										currentFrame = result.image;
										frameIndex++;
										if (frameIndex >= decoder.tracks.selectedTrack.frameCount) {
											// finished this item, advance
											var nextIndex = index + 1;
											if (nextIndex >= playlist.length) nextIndex = loopFrom;
											var hold = item.holdLast || 0;
											setTimeout(function() { playItem(nextIndex); }, hold);
											return;
										}
										var delay = result.image.duration ? result.image.duration / 1000 : 33;
										setTimeout(decodeNext, delay);
									}).catch(function() {
										frameIndex = 0;
										setTimeout(decodeNext, 100);
									});
								}
								decoder.tracks.ready.then(function() {
									decodeNext();
								});
							}).catch(function(err) {
								console.warn('Playlist item failed', item.url, err);
								var nextIndex = index + 1;
								if (nextIndex >= playlist.length) nextIndex = loopFrom;
								playItem(nextIndex);
							});
					}

					if (typeof ImageDecoder !== 'undefined') {
						playItem(0);
					} else {
						var img = new Image();
						img.onload = function() { currentFrame = img; };
						img.src = new URL(source, window.location.href).href;
					}

					renderLoop(performance.now());
					window.addEventListener('beforeunload', function() { cancelAnimationFrame(raf); }, { once: true });
				}
				initRedQueenTv();

				// 鼠标跟随光斑
				var glow = document.querySelector('.mesh-mouse-glow');
				if (glow) {
					var raf;
					var x = 0, y = 0;
					document.addEventListener('mousemove', function(e) {
						x = e.clientX;
						y = e.clientY;
						if (!raf) raf = requestAnimationFrame(function() {
							glow.style.setProperty('--mouse-x', x + 'px');
							glow.style.setProperty('--mouse-y', y + 'px');
							raf = 0;
						});
					});
				}

				// 悬浮预览卡：为链接添加 data-preview
				document.querySelectorAll('.mesh-prose-body a[href]').forEach(function(a) {
					var href = a.getAttribute('href') || '';
					if (!href || href.startsWith('#')) return;
					a.classList.add('mesh-link-preview');
					try {
						a.setAttribute('data-preview', href.startsWith('http') ? new URL(href, location.origin).hostname : href);
					} catch (_) {
						a.setAttribute('data-preview', href);
					}
				});

				// 段落滚动浮现
				var paras = document.querySelectorAll('.mesh-prose-body p, .mesh-prose-body h2, .mesh-prose-body h3, .mesh-prose-body pre, .mesh-prose-body blockquote, .mesh-prose-body ul, .mesh-prose-body ol');
				if (window.IntersectionObserver) {
					var io = new IntersectionObserver(function(entries) {
						entries.forEach(function(e) {
							if (e.isIntersecting) {
								e.target.classList.add('mesh-para-visible');
								io.unobserve(e.target);
							}
						});
					}, { rootMargin: '0px 0px -60px 0px', threshold: 0.1 });
					paras.forEach(function(p) { io.observe(p); });
				} else {
					paras.forEach(function(p) { p.classList.add('mesh-para-visible'); });
				}

				// Regenerate 按钮
				var regen = document.querySelector('.mesh-regenerate');
				var article = document.querySelector('.mesh-article');
				var scan = document.querySelector('.mesh-load-scan');
				if (regen && article) {
					regen.addEventListener('click', function() {
						regen.disabled = true;
						regen.classList.add('mesh-regenerating');
						article.classList.add('mesh-regenerate-flash');
						if (scan) {
							scan.style.animation = 'none';
							scan.offsetHeight;
							scan.style.animation = 'mesh-scan 0.8s ease-out forwards';
							scan.style.top = '0';
							scan.style.opacity = '1';
						}
						setTimeout(function() {
							article.classList.remove('mesh-regenerate-flash');
							regen.classList.remove('mesh-regenerating');
							regen.disabled = false;
						}, 1200);
					});
				}
			}

			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', init);
			} else {
				init();
			}
		})();
		</script>
	</body>
</html>
