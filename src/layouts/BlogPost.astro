---
import { Image } from 'astro:assets';
import type { CollectionEntry } from 'astro:content';
import BaseHead from '../components/BaseHead.astro';
import Footer from '../components/Footer.astro';
import FormattedDate from '../components/FormattedDate.astro';
import Header from '../components/Header.astro';

type Props = CollectionEntry<'blog'>['data'] & {
	related?: CollectionEntry<'blog'>[];
};

const { title, description, pubDate, updatedDate, heroImage, related = [] } = Astro.props;

// 终端风格日期
const fmt = (d: Date) => d.toISOString().slice(0, 10);

// 点云：全屏分散但不过于稀疏
const w = 1200; const h = 800;
const pts: { x: number; y: number; r: number; depth: number }[] = [];
const pad = 50;
for (let i = 0; i < 58; i++) {
	const x = pad + Math.random() * (w - pad * 2);
	const y = pad + Math.random() * (h - pad * 2);
	const depth = Math.random();
	pts.push({
		x, y,
		r: 1.1 + depth * 1.3,
		depth,
	});
}
const connectDist = 138;
const edges: [number, number][] = [];
for (let i = 0; i < pts.length; i++) {
	for (let j = i + 1; j < pts.length; j++) {
		const d = Math.hypot(pts[i].x - pts[j].x, pts[i].y - pts[j].y);
		if (d < connectDist) edges.push([i, j]);
	}
}
---

<html lang="en">
	<head>
		<BaseHead title={title} description={description} />
		<style>
			main {
				width: calc(100% - 2em);
				max-width: 100%;
				margin: 0;
			}
			.hero-image {
				width: 100%;
			}
			.hero-image img {
				display: block;
				margin: 0 auto;
				border-radius: 12px;
				box-shadow: var(--box-shadow);
			}
			.prose {
				width: 720px;
				max-width: calc(100% - 2em);
				margin: auto;
				padding: 1em;
				color: rgb(var(--text));
			}
			.title {
				margin-bottom: 1em;
				padding: 1em 0;
				text-align: center;
				line-height: 1;
			}
			.title h1 {
				margin: 0 0 0.5em 0;
			}
			.date {
				margin-bottom: 0.5em;
				color: rgb(var(--text-muted));
			}
			.last-updated-on {
				font-style: italic;
			}
		</style>
	</head>

	<body class="mesh-page">
		<div class="mesh-bg" aria-hidden="true">
			<div class="mesh-glow mesh-glow-shift"></div>
			<div class="mesh-haze" aria-hidden="true"></div>
			<div class="mesh-vignette" aria-hidden="true"></div>
			<div class="mesh-stripe"></div>
			<div class="mesh-noise" aria-hidden="true"></div>
			<div class="mesh-hex-grid" aria-hidden="true"></div>
			<div class="mesh-thought-particles" aria-hidden="true">
				{[...Array(12)].map((_, i) => (
					<span class="mesh-particle" style={`--x: ${20 + (i * 7) % 60}%; --y: ${10 + (i * 11) % 70}%; --d: ${3 + (i % 4)}s`}></span>
				))}
			</div>
			<svg class="mesh-network" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid slice">
				<defs>
					<linearGradient id="mesh-line-grad" x1="0%" y1="0%" x2="100%" y2="0%">
						<stop offset="0%" stop-color="rgba(180,235,255,0.18)" />
						<stop offset="50%" stop-color="rgba(220,248,255,0.55)" />
						<stop offset="100%" stop-color="rgba(180,235,255,0.18)" />
					</linearGradient>
					<filter id="mesh-dot-glow">
						<feGaussianBlur stdDeviation="1.5" result="blur" />
						<feMerge>
							<feMergeNode in="blur" />
							<feMergeNode in="SourceGraphic" />
						</feMerge>
					</filter>
				</defs>
				<g class="mesh-lines">
					{edges.map(([i, j]) => (
						<line
							x1={pts[i].x}
							y1={pts[i].y}
							x2={pts[j].x}
							y2={pts[j].y}
							stroke="url(#mesh-line-grad)"
							stroke-width="0.4"
						/>
					))}
				</g>
				<g class="mesh-dots">
					{pts.map((p) => (
						<circle
							cx={p.x}
							cy={p.y}
							r={p.r}
							fill={`rgba(220,252,255,${0.55 + p.depth * 0.4})`}
							filter="url(#mesh-dot-glow)"
						/>
					))}
				</g>
			</svg>
		</div>
		<Header />
		<div class="mesh-read-progress" aria-hidden="true"></div>
		<div class="mesh-mouse-glow" aria-hidden="true"></div>
		<div class="mesh-depth-blur" aria-hidden="true"></div>
		<div class="mesh-thinking-dots" aria-hidden="true"><span></span><span></span><span></span></div>
		<main class="mesh-content">
			<div class="mesh-load-scan" aria-hidden="true"></div>
			<article class="mesh-article">
				<div class="hero-image">
					{heroImage && <Image width={1020} height={510} src={heroImage} alt="" />}
				</div>
				<div class="prose">
					<div class="title mesh-title">
						<div class="mesh-meta-terminal">
							$ published {fmt(pubDate)}
							{updatedDate && <> | updated {fmt(updatedDate)}</>}
							{' '}| ~<span class="mesh-reading-time">…</span> min read
						</div>
						<div class="mesh-prompt-line">
							Prompt: <span class="mesh-prompt-topic">{description}</span> →
						</div>
						<h1 class="mesh-title-text">{title}</h1>
						<hr />
					</div>
					<div class="mesh-response-wrap">
						<div class="mesh-response-header">
							<div class="mesh-response-avatar" aria-hidden="true"></div>
							<span class="mesh-response-label">Response</span>
						</div>
						<div class="mesh-prose-body mesh-prose-fade">
							<slot />
							<span class="mesh-block-cursor" aria-hidden="true"></span>
						</div>
					</div>
					<div class="mesh-stats-corner">
						<span class="mesh-word-count">…</span> words · <span class="mesh-token-count">…</span> tokens
					</div>
					<button type="button" class="mesh-regenerate" aria-label="Regenerate">Regenerate</button>
				</div>
			</article>
			{related.length > 0 && (
				<section class="mesh-related" aria-label="Related posts">
					<h2 class="mesh-related-title">Related</h2>
					<div class="mesh-related-grid">
						{related.map((p) => (
							<a href={`/blog/${p.id}/`} class="mesh-related-card">
								{p.data.heroImage ? (
									<div class="mesh-related-img">
										<Image width={320} height={180} src={p.data.heroImage} alt="" />
									</div>
								) : (
									<div class="mesh-related-placeholder">
										<span>{p.data.title.charAt(0)}</span>
									</div>
								)}
								<h3 class="mesh-related-card-title">{p.data.title}</h3>
								<p class="mesh-related-card-date">
									<FormattedDate date={p.data.pubDate} />
								</p>
							</a>
						))}
					</div>
				</section>
			)}
			<nav class="mesh-back-to-blog" aria-label="Back to blog">
				<a href="/blog/">
					<span class="mesh-back-prompt">$</span>
					<span class="mesh-back-text">← Back to blog</span>
				</a>
			</nav>
		</main>
		<Footer />
		<script is:inline>
			(function() {
				function init() {
				// 阅读进度条
				var progress = document.querySelector('.mesh-read-progress');
				var article = document.querySelector('.mesh-article');
				if (progress && article) {
					function onScroll() {
						var rect = article.getBoundingClientRect();
						var viewH = window.innerHeight;
						var start = viewH;
						var end = -rect.height;
						var range = start - end;
						var scroll = Math.max(0, Math.min(1, (start - rect.top) / range));
						progress.style.setProperty('--read-progress', String(scroll));
					}
					onScroll();
					window.addEventListener('scroll', onScroll, { passive: true });
				}

				// 鼠标跟随光斑
				var glow = document.querySelector('.mesh-mouse-glow');
				if (glow) {
					var raf;
					var x = 0, y = 0;
					document.addEventListener('mousemove', function(e) {
						x = e.clientX;
						y = e.clientY;
						if (!raf) raf = requestAnimationFrame(function() {
							glow.style.setProperty('--mouse-x', x + 'px');
							glow.style.setProperty('--mouse-y', y + 'px');
							raf = 0;
						});
					});
				}

				// 悬浮预览卡：为链接添加 data-preview
				document.querySelectorAll('.mesh-prose-body a[href]').forEach(function(a) {
					var href = a.getAttribute('href') || '';
					if (!href || href.startsWith('#')) return;
					a.classList.add('mesh-link-preview');
					try {
						a.setAttribute('data-preview', href.startsWith('http') ? new URL(href, location.origin).hostname : href);
					} catch (_) {
						a.setAttribute('data-preview', href);
					}
				});

				// 阅读时间 + 字数/Token
				var body = document.querySelector('.mesh-prose-body');
				if (body) {
					var text = body.innerText || body.textContent || '';
					var words = text.trim().split(/\s+/).filter(Boolean).length;
					var mins = Math.max(1, Math.round(words / 220));
					var tokens = Math.round(words * 1.3);
					var wc = words >= 1000 ? (words/1000).toFixed(1) + 'k' : String(words);
					var tc = tokens >= 1000 ? (tokens/1000).toFixed(1) + 'k' : String(tokens);
					var rt = document.querySelector('.mesh-reading-time');
					var wce = document.querySelector('.mesh-word-count');
					var tce = document.querySelector('.mesh-token-count');
					if (rt) rt.textContent = mins;
					if (wce) wce.textContent = wc;
					if (tce) tce.textContent = tc;
				}

				// 段落滚动浮现
				var paras = document.querySelectorAll('.mesh-prose-body p, .mesh-prose-body h2, .mesh-prose-body h3, .mesh-prose-body pre, .mesh-prose-body blockquote, .mesh-prose-body ul, .mesh-prose-body ol');
				if (window.IntersectionObserver) {
					var io = new IntersectionObserver(function(entries) {
						entries.forEach(function(e) {
							if (e.isIntersecting) {
								e.target.classList.add('mesh-para-visible');
								io.unobserve(e.target);
							}
						});
					}, { rootMargin: '0px 0px -60px 0px', threshold: 0.1 });
					paras.forEach(function(p) { io.observe(p); });
				} else {
					paras.forEach(function(p) { p.classList.add('mesh-para-visible'); });
				}

				// Regenerate 按钮
				var regen = document.querySelector('.mesh-regenerate');
				var article = document.querySelector('.mesh-article');
				var scan = document.querySelector('.mesh-load-scan');
				if (regen && article) {
					regen.addEventListener('click', function() {
						regen.disabled = true;
						regen.classList.add('mesh-regenerating');
						article.classList.add('mesh-regenerate-flash');
						if (scan) {
							scan.style.animation = 'none';
							scan.offsetHeight;
							scan.style.animation = 'mesh-scan 0.8s ease-out forwards';
							scan.style.top = '0';
							scan.style.opacity = '1';
						}
						setTimeout(function() {
							article.classList.remove('mesh-regenerate-flash');
							regen.classList.remove('mesh-regenerating');
							regen.disabled = false;
						}, 1200);
					});
				}
				}

				if (document.readyState === 'loading') {
					document.addEventListener('DOMContentLoaded', init);
				} else {
					init();
				}
			})();
		</script>
	</body>
</html>
